### 序列化你真的了解吗？

#### `什么是序列化❓`

**以字节序列存储对象中的数据，这个过程就叫序列化。相反的，把存储字节序列恢复成对象数据，这个过程是反序列化。**
> 而这里字节序列有许多表现形式,根据具体协议来定义，常见有json,xml文件

#### **有啥用呢❓**

1. 序列化就是一种用来处理对象流的机制。所谓对象流也就是将对象的内容进行流化，让对象流能在网络传输
2. 序列化的目的，就是要以对象为单元进行数据存储，存储并不限于本地磁盘，可以是网络等环境。
3. 序列化屏蔽底层繁琐的编码、解码过程，完全以一种面向对象的理念进行数据存储。提高开发效率。

#### 同时序列化解决对象读写问题❗❗

`问题描述`⚠

读写对象会有什么问题呢？比如：我要将对象写入一个磁盘文件而后再将其读出来会有什么问题吗？别急，其中一个最大的**问题就是对象引用！**

`举个例子`来说：假如我有两个类，

分别是A和B，B类中含有一个指向A类对象的引用，现在我们对两个类进行实例化{ A a = new A(); B b = new B(); }。这时在内存中实际上分配了两个空间，一个存储对象a，一个存储对象b。接下来我们想将它们写入到磁盘的一个文件中去，就在写入文件时出现了问题⚠！因为`对象b包含对对象a的引用`，所以系统会`自动的将a的数据复制一份到b中`，这样的话当我们`从文件中恢复对象时(也就是重新加载到内存中)时，内存分配了三个空间`，而`对象a同时在内存中存在两份`，想一想后果吧，如果我想修改对象a的数据的话，那不是还要搜索它的每一份拷贝来达到对象数据的一致性，这不是我们所希望的

**怎么解决**

1.保存到磁盘的所有对象都获得一个序列号(1, 2, 3等等)，这就是序列化的版本号

2.当要保存一个对象时，先检查该对象是否被保存了

3.如果以前保存过，只需写入"与已经保存的具有序列号x的对象相同"的标记，否则，保存该对象

通过以上的步骤序列化机制解决了对象引用的问题！

#### 版本号

> 所有实现序列化的对象都必须要有个版本号，这个版本号可以由我们自己定义，当我们没定义的时候JDK工具会按照我们对象的属性生成一个对应的版本号。

##### **版本号的好处**

其实这个版本号就和我们平常软件的版本号一样，你的软件版本号和官方的服务器版本不一致的话就告诉你有新的功能更新了，主要用于提示用户进行更新。序列化也一样，我们的对象通常需要根据业务的需求变化要新增、修改或者删除一些属性，在我们做了一些修改后，就通过修改版本号告诉 反序列化的那一方对象有了修改你需要同步修改。

> 版本号保证对象的一致性

#### 不使用序列化的字段

- **static 属性不能被序列化**
- **Transient 属性不会被序列化，声明Transient 属性可以阻止字段序列化**

#### 序列化两种方式⬇⬇

-  将对象变成字节流，比如用 unicode 编码字符串，或用 Protobuf 编码对象。 这里面只涉及编码这一步。
-  将对象转换成公共的格式。 比如，把对象变成 json 或 xml 。

**序列化与编码区别**

> 序列化改变的是信息的编辑格式（高级语言识别）,编码是真的转换成了二进制数组了（计算机识别）

