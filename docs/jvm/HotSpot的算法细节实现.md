### HotSpot的算法细节实现

### **根节点枚举**

> 根节点枚举就是找出适合做GCRoot的引用对象

**以可达性分析算法中从GC Roots集合找引用链这个操作去查找对象引用**但是这种查找对象，GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如 栈帧中的本地变量表）中，查找做到高效并非一件容易的事情，**现在Java应 用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检 查以这里为起源的引用肯定得消耗不少时间**。

### 根节点枚举的条件

`所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的`

虽然，**可达性分析算法耗时 最长的查找引用链的过程已经可以做到与用户线程一起并发**

但是还是保证一致性

> 一致性：一致性的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。
>
> 一致性的保证是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因，即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、ZGC等收集器，枚举根节点时也是必须要停顿的。

### 准确式垃圾收集

使用一组称为OopMap的数据结构存储对象的存放的位置

**一旦类加载动作完成**的时候，HotSpot就会**把对象内什么偏移量上是什么类型的数据计算出来**，在即时编译过程中，也 会**在特定的位置记录下栈里和寄存器里哪些位置是引用**。

收集器在扫描时就可以直接得知这些信息了，并**不需要真正一个不漏地从方法区等GCRoots开始查找。**

> OopMap记录经历过的所有Java对象的集合

#### 对象回收的STW

回收对象，需要暂停其他线程

JVM中要做到STW是很难的。为什么这么说呢？因为需要考虑很多很多因素。

一、JVM中存在多种类型的会发生改变内存行为的线程：

1. 执行业务逻辑的用户线程
2. 执行native方法的Java线程
3. 执行垃圾收集的GC线程（并行并发垃圾收集需要考虑）
4. 执行即时编译的JIT线程


二、每种类型的线程个数，在需要STW的那一刻，可能都不止一个。

三、每种类型的线程，在需要STW的那一刻，执行到的代码位置也未可知。

四、每种类型的线程阻塞的点还不能随机。**因为线程在阻塞前需要更新OopMap**。OopMap是什么？你可以理解成是记录这个线程一路跑下来经历过的所有Java对象的集合。为什么要有OopMap呢？因为没有的话，你就得扫描整个栈，去查找根对象。

### 暂停线程

#### 安全点

因为OopMap要记录经历过的所有Java对象的集合，但是**OopMap要记录经历过的所有Java对象的集合不能一条指令记录一个OopMap，这样开销也太大，同时也不能记录某一时刻的对象，因为对象引用会发生改变**，所以我们需要的在一个时间点暂停线程操作，同时记录记录经历过的所有Java对象的集合，然后开始进行垃圾收集。这样能保证垃圾收集器准确完成GCRoot枚举

> 在特定位置记录生成OopMap，这些位置被叫做**安全点**

#### 如何暂停线程

- 抢先式中断
- 主动式中断

**抢先式中断** （Preemptive Suspension）和主动式中断（Voluntary Suspension），**抢先式中断不需要线程的执行代码 主动去配合，在垃圾收集发生时**，系统首先把所有用户线程全部中断，如果**发现有用户线程中断的地 方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在几乎没有虚 拟机实现采用抢先式中断来暂停线程响应GC事件。**



**主动式中断**的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一 个标志位，各个线程执行过程时会不停地主动去轮询这个标志，**一旦发现中断标志为真时就自己在最 近的安全点上主动中断挂起。**轮询标志的地方和安全点是重合的，另外还**要加上所有创建对象和其他 需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新 对象**

当需要暂停用户线程时，**虚拟机把0x160100的内存页设置为不可读，那线程执行到test指令时就会 产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待，这样仅通过一条汇编指 令便完成安全点轮询和触发线程中断了**