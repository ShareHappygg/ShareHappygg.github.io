## MySQL事务

### 不可重复读介绍

> 不可重复读 就**是一个事务读到另一个事务修改后并提交的数据（update）**。在同一个事务中，对于同一组数据读取到的结果不一致。比如，事务B 在 事务A 提交前读到的结果，和在 事务A 提交后读到的结果可能不同。不可重复读出现的原因就是由于事务并发修改记录而导致的。

### **隔离级别**

**隔离级别 有四种，分别是：读未提交、读已提交、可重复读、序列化。**

- 读未提交： Read Uncommitted，顾名思义，就是一个事务可以读取另一个未提交事务的数据。最低级别，它存在4个常见问题（脏读、不可重复读、幻读、丢失更新）。
- 读已提交： Read Committed，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。 它解决了脏读问题，存在3个常见问题（不可重复读、幻读、丢失更新）。
- 可重复读： Repeatable Read，就是在开始读取数据（事务开启）时，不再允许修改操作 。它解决了脏读和不可重复读，还存在2个常见问题（幻读、丢失更新）。
- 序列化： Serializable，序列化，或串行化。就是将每个事务按一定的顺序去执行，它将隔离问题全部解决，但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。
- 大多数数据库默认的事务隔离级别是 **Read Committed，比如 SQL Server , Oracle。但 MySQL 的默认隔离级别是 Repeatable Read。**
  

### 1、事例

程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他买单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务并提交完）。程序员就会很郁闷，明明卡里是有钱的…

### 2、分析

在这个事例中，涉及到了两个事务（程序员事务和妻子事务），当程序员事务开启时，收费系统读取程序员卡里钱的操作还没完成，此时妻子这个事务就将卡里的钱进行了转账，即对数据进行了修改，导致收费系统两次读取到的数据不一样。出现**了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读，这是由于数据更新导致的，不能重复读取相同的数据**

> 不可重复读：两次相同查询，返回不同数据，重复查询，却返回不同的数据