### 事务的基础

#### **事务的定义**

**事务是一组操作数据库的集合**。事务是现代数据库的理论中核心概念之一，如果一组处理步骤要么全部发生要么全部失败，该组处理步骤叫事务。**当所有步骤被完整执行时，我们称为该事务被提交**。如果**由于其中的一部分或多步执行失败，导致没有步骤被提交，则事务必须回滚到最初的系统状态。**

#### **事务ACID的特点**

- 1.原子性：一个事务中所有对数据库的操作是一个不可分割的操作序列，要么全做要么全不做
- 2.一致性：数据不会因为事务的执行而遭到破坏
- 3.隔离性：一个事物的执行，不受其他事务的干扰，即并发执行的事物之间互不干扰
- 4.持久性：一个事物一旦提交，它对数据库的改变就是永久的。

#### 事务的五种状态

**活动状态**
事务在执行时的状态叫活动状态。

**部分提交状态**
事务中最后一条语句被执行后的状态叫部分提交状态。

**失败状态**
事务不能正常执行的状态叫失败状态。

**提交状态**
事务在部分提交后，将往硬盘上写入数据，当最后一条信息写入后的状态叫提交状态。进入提交状态的事务就成功完成了。

**中止状态**
事务回滚并且数据库已经恢复到事务开始执行前的状态叫中止状态。

#### 事务的传播行为

> 对于Spring事务默认传播行为：Propagation.REQUIRED

**Propagation的属性（事务的传播行为）**

例如：@Transactional(propagation=Propagation.NOT_SUPPORTED,readOnly=true)

Propagation属性含义

- **REQUIRED**:默认值 在有transaction状态下执行；如当前没有transaction，则创建新的transaction；

- **SUPPORTS:**如当前有transaction，则在transaction状态下执行；如果当前没有transaction，在无transaction状态下执行；

- **MANDATORY:**必须在有transaction状态下执行，如果当前没有transaction，则抛出异常IllegalTransactionStateException；

- **REQUIRES_NEW**:创建新的transaction并执行；如果当前已有transaction，则将当前transaction挂起；

- **NOT_SUPPORTED:**在无transaction状态下执行；如果当前已有transaction，则将当前transaction挂起；

- **NEVER**:在无transaction状态下执行；如果当前已有transaction，则抛出异常IllegalTransactionStateException。

- **NESTED**：事务申明在调用者上会新建一个独立事务。申明在被调用者上，若调用者存在事务则加入调用者事务。调用者不存在事务则新建一个独立事务。

  > **NESTED**与**REQUIRED**区别**NESTED**可以让事务部分回滚

#### 事务的5种隔离级别

> mysql事务隔离级别是可重复读

| 隔离级别         | 含义                                                         |
| ---------------- | ------------------------------------------------------------ |
| DEFAULT          | 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别. 另外四个与JDBC的隔离级别相对应； |
| READ_UNCOMMITTED | 最低的隔离级别。事实上我们不应该称其为隔离级别，因为在事务完成前，其他事务可以看到该事务所修改的数据。而在其他事务提交前，该事务也可以看到其他事务所做的修改。可能导致脏，幻，不可重复读 |
| READ_COMMITTED   | 大多数数据库的默认级别。**在事务完成前，其他事务无法看到该事务所修改的数据**。遗憾的是，**在该事务提交后，你就可以查看其他事务插入或更新的数据。**这意味着在事务的不同点上，如果其他事务修改了数据，你就会看到不同的数据。可防止脏读，但幻读和不可重复读仍可以发生。 |
| REPEATABLE_READ  | 比ISOLATION_READ_COMMITTED更严格，**该隔离级别确保如果在事务中查询了某个数据集，你至少还能再次查询到相同的数据集，即使其他事务修改了所查询的数据。然而如果其他事务插入了新数据，你就可以查询到该新插入的数据**。可防止脏读，不可重复读，但幻读仍可能发生。 |
| SERIALIZABLE     | 完全服从ACID的隔离级别，***确保不发生脏读、不可重复读和幻影读***。这在所有隔离级别中也是最慢的，因**为它通常是通过完全锁定当前事务所涉及的数据表来完成的。代价最大、可靠性最高的隔离级别，所有的事务都是按顺序一个接一个地执行。避免所有不安全读取**。 |