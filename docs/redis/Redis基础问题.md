### Redis基础问题

### `redis是什么类型的数据库❓`

- nosql数据库

### redis既然是nosql数据库，那么nosql与sql数据库有什么不同？

- 一张图解释

  ![image-20221027135118529](C:\Users\coder\AppData\Roaming\Typora\typora-user-images\image-20221027135118529.png)

### 说说使用redis好处👍`

- 支持多种不同数据结构
- 单线程，每个命令具备原子性
- 低延迟，速度快（`基于内存`，IO多路复用，良好编码）
- 支持数据持久化（定期把数据放入磁盘）
- 支持主从集群，分片集群
- 支持事务，同时Redis还支持对几个操作合并后的原子性执行

### 为什么说redis读写速度快

- **基于内存**：Redis是使用内存存储，没有磁盘IO上的开销。数据存在内存中，读写速度快。CPU不是 Redis性能瓶颈，Redis的瓶颈是机器内存和网络带宽
- **IO多路复用模型**：Redis 采用 IO 多路复用技术。Redis 使用单线程来轮询描述符，将数据库的操作都转换成了事件，不在网络I/O上浪费过多的时间。
- **高效的数据结构**：Redis 每种数据类型底层都做了优化，目的就是为了追求更快的速度。

### redis数据结构有什么，一般应用场景❓`

- String----实现分布锁
- Hash表---存在复杂json结构
- Set----实现复杂交集、并集、差集等功能--好友关系
- List---消息队列
- SortedSet-----排行榜
- GEO 坐标 ----地理相关计算经纬度
- BitMap 二进制----签到计算
- HyperLog ----计算访问量

### SortedSet和List异同点？

**相同点**：

1. 都是有序的；
2. 都可以获得某个范围内的元素。

**不同点：**

1. 列表基于链表实现，获取两端元素速度快，访问中间元素速度慢；
2. 有序集合基于散列表和跳跃表实现，访问中间元素时间复杂度是OlogN；
3. 列表不能简单的调整某个元素的位置，有序列表可以（更改元素的分数）；
4. 有序集合更耗内存

### keys命令使用的问题

Redis KEYS 命令用于查找所有符合指定模式（pattern）的 key。在线上上产环境，该命令被禁止使用，一次性查询大量的 key，会导致服务性能受到影响。

### 使用scan遍历问题❓

**redis里边rehash扩容从小到大时，scan系列命令不会重复也不会遗漏.而从大到小时,有可能会造成重复但不会遗漏.**

### 

### redis缓存的优缺点

缓存好处

- 降低后端负载提高读写效率，
- 降低响应时间

缓存缺点：

- 对结构化查询的支持比较差。
- 数据库容量受到物理内存的限制，不适合用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的操作。
- Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。



### `redis有哪些缓存更新策略，它们应用在哪些业务场景❓`

- **内存淘汰：**redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)
- **超时剔除：**当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存
- **主动更新：**我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题

![image-20221017162116050](C:\Users\coder\AppData\Roaming\Typora\typora-user-images\image-20221017162116050.png)
- **业务场景：**
- 低一致性需求：使用内存淘汰机制。例如店铺类型的查询缓存
- 高一致性需求：主动更新，并以超时剔除作为兜底方案。例如店铺详情查询的缓存

### 在高并发场景下，redis缓存常见问题有哪些，以及解决方案❓

- 缓存穿透

- 缓存雪崩

- 缓存击穿

- **缓存穿透**：指的是访问一个的**不存在的数据**，发送请求的访问的不存在数据，所以每次的请求的都要访问的数据库，但是数 

  据库也无此记录，我们没有将这次查询的 null 写入缓存，这**将导致这个不存在的数据每次 请求都要到存储层去查询**，失去了缓存的意义

  **在流量大时**，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞

  **解决方法：**

  * 缓存空对象
    * 优点：实现简单，维护方便
    * 缺点：
      * 额外的内存消耗
      * 可能造成短期的不一致
  * 布隆过滤
    * 优点：内存占用较少，没有多余key
    * 缺点：
      * 实现复杂
      * 存在误判可能
      * 增强id的复杂度，避免容易猜测id规则
      * 做好数据的基础格式校验
      * 加强用户权限校验
      * 做热点参数的限流

- **缓存雪崩**:是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB，DB 瞬时压力过重雪崩。 

  **解决方法：** 

  > 原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的 重复率就会降低，就很难引发集体失效的事件。 

  **缓存雪崩发生后**

  - 使用熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。
  - 提高数据库的容灾能力，可以使用分库分表，读写分离的策略。
  - 为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性(redis哨兵)。

- **缓存击穿**是一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。

  **解决方法：**

  > 使用互斥锁。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死。当然这样会导致系统的性能变差。

  **解决方法：**

  - 使用互斥锁。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死。当然这样会导致系统的性能变差。

    - 缺点：线程等待时间过长，性能差

  - 逻辑过期 永不过期

    - 获取互斥锁，开启新线程重建redis,拿旧数据