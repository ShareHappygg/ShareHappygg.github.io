### 乐观锁CAS操作

#### **什么是CAS？**

CAS：Compare and Swap，即比较再交换。

对CAS的理解，CAS是一种无锁算法，**CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B**。

> 当且仅当预期值A和内存值V相同时，将内存值V修改为B，
>
> 也就是比较内存值的v是否与预期值A相同，若相同进行交换预期值A与新值B进行交换

`CAS（比较并交换）是CPU指令级的操作，只有一步原子操作，所以非常快。而且CAS避免了请求操作系统来裁定锁的问题，不用麻烦操作系统，直接在CPU内部就搞定了。`

#### CAS的问题

**CAS是具有原子性的，于是利用循环 + CAS来确保线程安全**

`**CAS存在ABA问题**：`

比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。
 **AtomicStampedReference**来解决ABA问题:这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

```cpp
public boolean compareAndSet(
               V      expectedReference,//预期引用
               V      newReference,//更新后的引用
              int    expectedStamp, //预期标志
              int    newStamp //更新后的标志

)
```

`循环时间长开销大`

自旋CAS 如果长时间不成功，会给CPU 带来非常大的执行开销。

**`只能保证一个共享变量的原子操作。`**

当对一个共享变量执行操作时，我们可以使用循环CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环CAS 就无法保证操作的原子性，这个时候就可以用锁。

还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。

