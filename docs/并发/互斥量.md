### 前言

> notify方法和wait()方法本质使用到互斥量来发送信号来阻塞线程和唤醒线程，让我们了解下互斥量

### 互斥量

**互斥量是一个可以处于两态之一的变量：解锁和加锁。**这样，只需要一个`二进制位`表示它，不过实际上，常常使用一个整型量，0表示解锁，而其他所有的值则表示加锁。

当一个线程 （或进程）需要访问临界区时，它调用mutex_lock。如果该互斥量当前是解锁的（即临界区(监视器区域)可用），此调用成功，调用线程可以自由进入该临界区（监视器区域）

另一方面，如果该互斥量已经加锁，调用线程被阻塞，直到在临界区中的线程完成并调用 mutex_unlock。如果多个线程被阻塞在该互斥量上，将随机选择一个线程并允许它获得锁

### Pthread中的互斥

Pthread提供许多可以用来同步线程的函数。其基本机制是使用一个可以被锁定和解锁的互斥量来保护每个临界区。一个线程如果想要进入临界区，它首先尝试锁住相关的互斥量。如果互斥量没有加锁，那么这个线程可以立即进入，并且该互斥量被自动锁定以防止其他线程进入。如果互斥量已经被加锁，则调用线程被阻塞，直到该互斥量被解锁。如果`多个线程在等待同一个互斥量`，当它被解锁时，这些等待的线程中`只有一个被允许`运行并将互斥量重新锁定。

**主要函数调用**

![互斥量](https://blog-img-qrx.oss-cn-beijing.aliyuncs.com/img/互斥量.png)

除互斥量之外，pthread提供了另一种同步机制：条件变量。**互斥量在允许或阻塞对临界区的访问上是很有用的**，**条件变量则允许线程由于一些未达到的条件而阻塞**。绝大部分情况下这两种方法是一起使用的

举一个简单的例子，再次考虑一下生产者-消费者问题：一个线程将产品放在一个缓冲区内，由另一个线程将它们取出。如果生**产者发现缓冲区中没有空槽可以使用了，它不得不阻塞起来直到有一个空槽可以使用**。生产者使用**互斥量可以进行原子性检查，保证获得空槽的生产者是一开始没的用空槽用的生产者**，而不受其他线程干扰。但是**当发现缓冲区已经满了以后**，**生产者需要一种方法来阻塞自己并在以后被唤醒**。这便是条件变量做的事了

与条件变量相关的pthread调用如图所示

![条件变量](https://blog-img-qrx.oss-cn-beijing.aliyuncs.com/img/条件变量.png)

条件变量与互斥量经常一起使用。这种模式用于让一个线程锁住一个互斥量，然后当它不能获得它期待的结果时等待一个条件变量（**也就是缓冲区为空**）。最后另一个线程会向它发信号，使它可以继续执行

> 值得指出的是，条件变量（不像信号量）不会存在内存中。如果将一个信号量传递给一个没有线程在等待的条件变量（**满足不了条件**），那么这个信号就会丢失。程序员必须小心使用避免丢失信号

原文链接：https://blog.csdn.net/m0_51174487/article/details/119732563