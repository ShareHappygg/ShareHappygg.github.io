## 线程池

### 👉什么是线程池

线程池是**指在初始化一个多线程应用程序过程中创建一个线程集合**，然后在**需要执行新的任务时重用这些线程而不是新建一个线程**。线程池中线程的数量**通常完全取决于可用内存数量和应用程序的需求**。然而，增加可用线程数量是可能的。**线程池中的每个线程都有被分配一个任务，一旦任务已经完成了，线程回到池子中并等待下一次分配任务。**

### 为什么要使用线程池

因为创建和销毁线程都是需要时间的，特别是需要`创建大量线程的时候，时间和资源的消耗是不可忽略的，而合理的使用线程池中已经创建的线程，可以减少创建和销毁线程而花费的时间和资源。`

线程池的优点❓

1. 降低资源消耗：通过线程的重用可以降低创建和销毁线程花费的时间和资源；
2. 提高响应速度：任务到达时，因为利用线程池中已经创建好的线程，可以不用等待线程创建而直接执行任务；
3. 提高线程的可管理性：线程池允许我们开启多个任务而不用为每个线程设置属性（便于管理）；线程池根据当前在系统中运行的进程来优化线程时间片（调优）；线程池可以限制创建线程的数量，如果无限制的创建线程，不仅会消耗资源，还会降低系统的稳定性；


### **线程池的工作原理**🎯

当向线程池提交一个任务以后，线程池处理任务的流程大概如下：

1、**判断核心线程池是否满？如果没有，那么创建线程并执行任务；如果满，那么进入2**；

2、**判断阻塞队列（BlockingQueue）是否满？如果没有，那么把任务添加到阻塞队列中；如果满，进入3；**

3、**判断线程池是否满？如果没有，那么创建线程并执行任务；如果满，那么进入饱和策略（RejectionExecutionHandler）；**

4、如果核心线程池的线程执行完当前任务，**那么立刻从阻塞队列头取任务来执行，如果队列为空，且当前线程超过了存活时间（keepAliveTime），那么判断当前线程数是否大于核心线程池的最大数（corePoolSize）？**如果是，那么销毁当前线程，如果不是则保留当前线程。因此当创建的线程数大于核心线程池的最大数（corePoolSize），在所有任务执行完毕以后，**线程池最终线程数量会回到corePoolSize。**

![img](https://blog-img-qrx.oss-cn-beijing.aliyuncs.com/img/2018031820452092)

**注意：**

**为什么要使用“核心线程池+阻塞队列+线程池”这样的设计思路？**

因为**创建新线程需要获取全局锁，为了避免频繁的获取全局锁，因此使用了一个阻塞队列来存储任务**，如果核心线程池中的**线程执行的任务周期短，那么在执行完毕后立刻从阻塞队列中获取任务，就避免了重新创建新线程，使线程的重复利用率提高，然而如果核心线程池中线程执行的任务周期长，使得阻塞队列满还不断的提交任务，这个时候再创建线程，使用一个核心线程池一个线程池是因为核心线程池容量不能太大，不然阻塞队列的缓存作用就降低了**，**但是线程池数量如果太小，就限制了并发的线程数，降低了CPU的利用率**。

### 关闭线程池

可以通过shutdown或者shutDownNow来关闭线程池。

原理：**遍历线程池中的线程，逐个调用线程的interrupt（）方法来中断线程，所以不响应中断的线程可能永远无法终止**

- shutDown:把线程池的状态设置为SHUTDOWN，然后中断所有没有正在执行任务的线程，而已经在执行任务的线程继续执行直到任务执行完毕；

- shutDownNow：把当前线程池状态设为STOP，尝试停止所有的正在执行或者暂停的线程，并返回等待执行的任务的列表；

- 在调用了shutDown或者shutDownNow后，调用isShutDown（）返回true；当所有任务都关闭后，调用isTerminaed（）方法返回true。（注意关闭线程池和所有线程关闭是不同的）

### 线程池的合理配置📝

1. CPU（计算）密集型则**线程数配置尽可能的少，比如NCPU+1。可以通过Runtime.getRuntime().avaliableProcessors(  )方法获得当前设备的CPU数量；**

2. **IO密集型需要配置尽可能多的线程数，比如2*NCPU，因为IO处理时线程阻塞的时间很长，导致CPU空闲时间很长，多一点线程可以提高CPU利用率；**
3. **混合型任务：如果可以拆分，最好拆分成CPU密集型任务+IO密集型任务，只要这两个拆分后的任务执行时间相差没有太大，那么拆分后的吞吐量将高于串行执行的吞吐量，如果时间相差太大，就没有必要分解**；
4. 优先级不同的任务：**使用PriorityQueue作为阻塞队列。（如果一直有优先级高的任务进来，可能导致优先级低的任务无法执行）**

5. **执行时间不同的任务：可以交给不同规模的线程池来执行；或者使用PriorityQueue作为阻塞队列，把执行时间短的任务优先级设置高一点，让时间短的任务先执行；**
6. 建议**使用有界队列，这样可以保证系统的稳定性，如果队列时无界的，那么一直有任务进来就一直往阻塞队列添加节点，可能导致内存溢出。**